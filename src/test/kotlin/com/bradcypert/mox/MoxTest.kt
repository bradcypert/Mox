/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.bradcypert.mox

import kotlin.test.Test
import kotlin.test.assertTrue

data class User(val name: String)

interface Repo<T> {
    fun create(item: T)
    fun read(id: Int): T
    fun update(id: Int, item: T)
    fun delete(id: Int)
    fun delete(item: T)
}

class UserRepo : Repo<User> {
    override fun create(item: User) {
        throw Exception("CALLED ACTUAL CREATE")
    }

    override fun read(id: Int): User {
        throw Exception("CALLED ACTUAL READ")
    }

    override fun update(id: Int, item: User) {
        throw Exception("CALLED ACTUAL UPDATE")
    }

    override fun delete(id: Int) {
        throw Exception("CALLED ACTUAL DELETE ID")
    }

    override fun delete(item: User) {
        throw Exception("CALLED ACTUAL DELETE ITEM")
    }
}

class ViewModel(val repo: Repo<User>) {
    fun getUser(id: Int): User {
        return repo.read(id)
    }
}

class MoxTest {
    @Test fun stubsWork() {
        var isCalled = false
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.stub(classUnderTest, classUnderTest::read) {
            isCalled = true
        }

        classUnderTest.read(1)

        assert(isCalled)
    }

    @Test fun stubMultipleWorks() {
        var isCalled = false
        var isCalled2 = false
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.stub(classUnderTest, classUnderTest::read) {
            isCalled = true
        }

        val classUnderTest2 = UserRepo::class.mock() as Repo<*>

        Mox.stub(classUnderTest2, classUnderTest::read) {
            isCalled2 = true
        }

        classUnderTest.read(1)
        classUnderTest2.read(1)

        assert(isCalled)
        assert(isCalled2)
    }

    @Test fun restubbingWorks() {
        var isCalled = false
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.stub(classUnderTest, classUnderTest::read) {
            isCalled = false
        }

        Mox.stub(classUnderTest, classUnderTest::read) {
            isCalled = true
        }

        classUnderTest.read(1)

        assert(isCalled)
    }

    @Test fun stubbingAcceptsParameters() {
        var isCalled = false
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.stub(classUnderTest, classUnderTest::read) { args: Array<Any> ->
            if (args.first() == 1) {
                isCalled = true
            } else {
                throw IllegalArgumentException("1 was not passed to the mocked function")
            }
        }
        classUnderTest.read(1)
        assert(isCalled)
    }

    @Test fun respondingWorks() {
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.respond(classUnderTest, classUnderTest::read) {
            return@respond User(name = "Brad")
        }

        val result = classUnderTest.read(1) as User

        assert(result.name == "Brad")
    }

    @Test fun respondingWorksWithoutTheNeedForAFunction() {
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.respond(classUnderTest, classUnderTest::read, User(name = "Brad"))

        val result = classUnderTest.read(1) as User

        assert(result.name == "Brad")
    }

    @Test fun respondingAcceptsParameters() {
        val classUnderTest = UserRepo::class.mock() as Repo<*>
        Mox.respond(classUnderTest, classUnderTest::read) { args: Array<Any> ->
            if (args.first() == 1) {
                return@respond User(name = "Brad")
            } else {
                throw IllegalArgumentException("1 was not passed to the mocked function")
            }
        }

        val result = classUnderTest.read(1) as User
        assert(result.name == "Brad")
    }

    @Test fun respondingWorksInADependentSituation() {
        //TODO:: How do I get this to infer the Repo with the appropriate generic, * works
        val classUnderTest = UserRepo::class.mock() as Repo<User>

        Mox.respond(classUnderTest, classUnderTest::read) {
            return@respond User(name = "Brad")
        }

        class Wrapper(val repo: Repo<User>) {
            fun findUserById(id: Int): User = repo.read(id)
        }

        val wrapper = Wrapper(classUnderTest)

        val result = wrapper.findUserById(1)

        assert(result.name == "Brad")
    }


    @Test fun isMock() {
        val classUnderTest = UserRepo::class.mock()
        assertTrue(Mox.isMock(classUnderTest))
    }
}
